#include "gtest/gtest.h"
#include <math.h>
#include "maxwell/Hopfion.h"
#include "maxwell/Types.h"
#include "maxwell/Solver.h"
#include "../TestGlobalFunctions.h"

#include <fstream>

using namespace maxwell;


double hopfionLineEx(const Position& pos)
{
	Hopfion hopfion(1, 1);
	Vector hopfionPos(pos.Size());
	hopfionPos = 0.0;
	for (int i = 0; i < hopfionPos.Size(); i++) {
		hopfionPos[i] = 10 * (pos[i] - 3.0) + 1.0;
	}
	return hopfion.getEX(-1.4, hopfionPos[X], hopfionPos[Y], hopfionPos[Z]);
}


class TestHopfion : public ::testing::Test {
protected:

	double u0_function(const Position& x) const
	{
		return exp(-40. * pow(x[X]- 0.5, 2));

	}

	maxwell::Solver::Options buildDefaultSolverOpts(const double tFinal = 2.0)
	{
		maxwell::Solver::Options res;

		res.evolutionOperatorOptions = FiniteElementEvolution::Options();
		res.evolutionOperatorOptions.fluxType = FluxType::Centered;
		res.t_final = tFinal;

		return res;
	}


	Probes buildProbesWithDefaultPointsProbeHop()
	{
		Probes res;
		res.vis_steps = 20;
		res.addPointsProbeToCollection(PointsProbe(E, X,
			std::vector<std::vector<double>>{ { -0.75, -0.75, 0.75 }, { 0.75, 0.75, -0.75 }, { 0.00, 0.00, 0.00 },
												{ 0.75, -0.75, 0.75 }, { -0.75, 0.75, -0.75 } }));

		res.addPointsProbeToCollection(PointsProbe(E, Y,
			std::vector<std::vector<double>>{ { -0.75, -0.75, 0.75 }, { 0.75, 0.75, -0.75 }, { 0.00, 0.00, 0.00 },
			{ 0.75, -0.75, 0.75 }, { -0.75, 0.75, -0.75 } }));

		res.addPointsProbeToCollection(PointsProbe(E, Z,
			std::vector<std::vector<double>>{ { -0.75, -0.75, 0.75 }, { 0.75, 0.75, -0.75 }, { 0.00, 0.00, 0.00 },
			{ 0.75, -0.75, 0.75 }, { -0.75, 0.75, -0.75 } }));

		res.addPointsProbeToCollection(PointsProbe(H, X,
			std::vector<std::vector<double>>{ { -0.75, -0.75, 0.75 }, { 0.75, 0.75, -0.75 }, { 0.00, 0.00, 0.00 },
			{ 0.75, -0.75, 0.75 }, { -0.75, 0.75, -0.75 } }));

		res.addPointsProbeToCollection(PointsProbe(H, Y,
			std::vector<std::vector<double>>{ { -0.75, -0.75, 0.75 }, { 0.75, 0.75, -0.75 }, { 0.00, 0.00, 0.00 },
			{ 0.75, -0.75, 0.75 }, { -0.75, 0.75, -0.75 } }));

		res.addPointsProbeToCollection(PointsProbe(H, Z,
			std::vector<std::vector<double>>{ { -0.75, -0.75, 0.75 }, { 0.75, 0.75, -0.75 }, { 0.00, 0.00, 0.00 },
			{ 0.75, -0.75, 0.75 }, { -0.75, 0.75, -0.75 } }));

		return res;
	}

	std::map<Time, FieldFrame>::const_iterator findTimeId(
		const std::map<Time, FieldFrame>& timeMap,
		const Time& timeToFind,
		const double tolerance)
	{
		for (auto it = timeMap.begin(); it != timeMap.end(); it++) {
			const Time& time = it->first;
			if (abs(time - timeToFind) < tolerance) {
				return it;
			}
		}
		return timeMap.end();
	}

	double getBoundaryFieldValueAtTime(
		const PointsProbe& probe,
		const Time& timeToFind,
		const int denseMatPointByOrder)
	{
		auto itpos = findTimeId(probe.getConstFieldMovie(), timeToFind, 1e-6);
		if (itpos == probe.getConstFieldMovie().end()) {
			throw std::exception("Time value has not been found within the specified tolerance.");
		}
		auto FieldValueForTimeAtPoint = itpos->second.at(denseMatPointByOrder).at(probe.getDirection());

		return FieldValueForTimeAtPoint;
	}
};

TEST_F(TestHopfion, initialConditionForHopfionwithRef) {
	/*This test check if the values generated by the class Hopfion are the right..*/



	std::string path = "testData/hopfion/";
	
	std::string casename = "hopfion_p1_q1.txt";
	Hopfion hopfion(1, 1);

	std::ifstream inputFile; 
	std::string filename = path + casename;
	inputFile.open(filename);
	if (!inputFile.is_open()) {
		throw std::runtime_error("Could not open file: " + filename);
	}

	while (!inputFile.eof()) {
		double t;
		Hopfion::Vec3 pos, referenceE, referenceH;
		inputFile >> t 
			>> pos[0] >> pos[1] >> pos[2]
			>> referenceE[0] >> referenceE[1] >> referenceE[2] 
			>> referenceH[0] >> referenceH[1] >> referenceH[2];

		Hopfion::FieldEH computed = hopfion.evaluate(t, pos);

		for (std::size_t d = 0; d < 3; d++) {
			EXPECT_NEAR(referenceE[d], computed.first[d], 1e-8);
			EXPECT_NEAR(referenceH[d], computed.second[d], 1e-8);
		}
		
	}
	
}

TEST_F(TestHopfion, initialConditionForHopfionWithGet) {

	/*This test check the initial condition for the Hopfion using the eval fuctions*/


	double x, y, z, rEx, rEy, rEz, rHx, rHy, rHz;
	Time t;

	std::string path = "testData/hopfion/"; // -4, +6

	std::string casename = "hopfion_p1_q1.txt";
	Hopfion hopfion(1, 1);

	std::ifstream inputFile;
	std::string filename = path + casename;
	inputFile.open(filename);
	if (!inputFile.is_open()) {
		throw std::runtime_error("Could not open file: " + filename);
	}

	while (!inputFile.eof()) {

		inputFile >> t >> x >> y >> z >> rEx >> rEy >> rEz >> rHx >> rHy >> rHz;

		double cEx = hopfion.getEX(t, x, y, z);
		double cEy = hopfion.getEY(t, x, y, z);
		double cEz = hopfion.getEZ(t, x, y, z);

		double cHx = hopfion.getHX(t, x, y, z);
		double cHy = hopfion.getHY(t, x, y, z);
		double cHz = hopfion.getHZ(t, x, y, z);


		EXPECT_NEAR(rEx, cEx, 1e-8);
		EXPECT_NEAR(rEy, cEy, 1e-8);
		EXPECT_NEAR(rEz, cEz, 1e-8);
		EXPECT_NEAR(rHx, cHx, 1e-8);
		EXPECT_NEAR(rHy, cHy, 1e-8);
		EXPECT_NEAR(rHz, cHz, 1e-8);

	}
}
TEST_F(TestHopfion, HopfionRun) {

	/*This test check if it is possible to apply the Solver to run the initial condition of the hopfion.*/

	
	Mesh mesh = Mesh::MakeCartesian3D(3, 3, 3, Element::Type::HEXAHEDRON); //, 10, 10, 10
	Model model = Model(mesh, AttributeToMaterial(), AttributeToBoundary());

	Probes probes;
	probes.addExporterProbeToCollection(ExporterProbe());
	probes.vis_steps = 20;

	Sources sources;
	sources.addSourceToVector(Source(model, E, Y, 2.0, 1.0, Vector({ 1.0, 1.0, 1.0 }), SourceType::Hopfion));

	maxwell::Solver::Options solverOpts = buildDefaultSolverOpts(1.5);
	solverOpts.order = 3;

	maxwell::Solver solver(model, probes, sources, solverOpts);

	GridFunction eOldX = solver.getFieldInDirection(E, X);
	GridFunction eOldY = solver.getFieldInDirection(E, Y);
	GridFunction eOldZ = solver.getFieldInDirection(E, Z);
	GridFunction hOldX = solver.getFieldInDirection(H, X);
	GridFunction hOldY = solver.getFieldInDirection(H, Y);
	GridFunction hOldZ = solver.getFieldInDirection(H, Z);
	solver.run();
	GridFunction eNewX = solver.getFieldInDirection(E, X);
	GridFunction eNewY = solver.getFieldInDirection(E, Y);
	GridFunction eNewZ = solver.getFieldInDirection(E, Z);
	GridFunction hNewX = solver.getFieldInDirection(H, X);
	GridFunction hNewY = solver.getFieldInDirection(H, Y);
	GridFunction hNewZ = solver.getFieldInDirection(H, Z);


	double Eie = pow(eOldX.Norml2(), 2.0) + pow(eOldY.Norml2(), 2.0) + pow(eOldZ.Norml2(), 2.0);
	double Eih = pow(hOldX.Norml2(), 2.0) + pow(hOldY.Norml2(), 2.0) + pow(hOldZ.Norml2(), 2.0);

	double Efe = pow(eNewX.Norml2(), 2.0) + pow(eNewY.Norml2(), 2.0) + pow(eNewZ.Norml2(), 2.0);
	double Efh = pow(hNewX.Norml2(), 2.0) + pow(hNewY.Norml2(), 2.0) + pow(hNewZ.Norml2(), 2.0);

	EXPECT_GE(Eie + Eih, Efe + Efh);
}


TEST_F(TestHopfion, probeHopfion)
{
	// This test check if some computed value coincide the analitical values of the hopfion.

	
	Mesh mesh = Mesh::MakeCartesian3D(1, 1, 1, Element::Type::HEXAHEDRON);
	Model model = Model(mesh, AttributeToMaterial(), AttributeToBoundary());

	Sources sources;
	sources.addSourceToVector(Source(model, E, Y, 2.0, 1.0, Vector({ 1.0, 1.0, 1.0 }), SourceType::Hopfion));

	maxwell::Solver::Options solverOpts = buildDefaultSolverOpts();
	//solverOpts.order = 4;

	maxwell::Solver solver(model, buildProbesWithDefaultPointsProbeHop(), sources, solverOpts);

	GridFunction eOldX = solver.getFieldInDirection(E, X);
	GridFunction eOldY = solver.getFieldInDirection(E, Y);
	GridFunction eOldZ = solver.getFieldInDirection(E, Z);
	GridFunction hOldX = solver.getFieldInDirection(H, X);
	GridFunction hOldY = solver.getFieldInDirection(H, Y);
	GridFunction hOldZ = solver.getFieldInDirection(H, Z);
	solver.run();
	GridFunction eNewX = solver.getFieldInDirection(E, X);
	GridFunction eNewY = solver.getFieldInDirection(E, Y);
	GridFunction eNewZ = solver.getFieldInDirection(E, Z);
	GridFunction hNewX = solver.getFieldInDirection(H, X);
	GridFunction hNewY = solver.getFieldInDirection(H, Y);
	GridFunction hNewZ = solver.getFieldInDirection(H, Z);

	Hopfion hopfion(1, 1);

	// Punto 1: { -0.75, -0.75, 0.75 }
	EXPECT_NEAR(hopfion.getEX(0, -0.75, -0.75, 0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(0), 0.0, 0), 2e-3);
	EXPECT_NEAR(hopfion.getEY(0, -0.75, -0.75, 0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(1), 0.0, 0), 2e-3);
	EXPECT_NEAR(hopfion.getEZ(0, -0.75, -0.75, 0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(2), 0.0, 0), 2e-3);
	EXPECT_NEAR(hopfion.getHX(0, -0.75, -0.75, 0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(3), 0.0, 0), 2e-3);
	EXPECT_NEAR(hopfion.getHY(0, -0.75, -0.75, 0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(4), 0.0, 0), 2e-3);
	EXPECT_NEAR(hopfion.getHZ(0, -0.75, -0.75, 0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(5), 0.0, 0), 2e-3);

	EXPECT_NEAR(hopfion.getEX(1.5, -0.75, -0.75, 0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(0), 1.5, 0), 2e-3);
	EXPECT_NEAR(hopfion.getEY(1.5, -0.75, -0.75, 0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(1), 1.5, 0), 2e-3);
	EXPECT_NEAR(hopfion.getEZ(1.5, -0.75, -0.75, 0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(2), 1.5, 0), 2e-3);
	EXPECT_NEAR(hopfion.getHX(1.5, -0.75, -0.75, 0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(3), 1.5, 0), 2e-3);
	EXPECT_NEAR(hopfion.getHY(1.5, -0.75, -0.75, 0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(4), 1.5, 0), 2e-3);
	EXPECT_NEAR(hopfion.getHZ(1.5, -0.75, -0.75, 0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(5), 1.5, 0), 2e-3);


	// Punto 2: { 0.75, 0.75, -0.75 }
	EXPECT_NEAR(hopfion.getEX(0, 0.75, 0.75, -0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(0), 0.0, 0), 2e-3);
	EXPECT_NEAR(hopfion.getEY(0, 0.75, 0.75, -0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(1), 0.0, 0), 2e-3);
	EXPECT_NEAR(hopfion.getEZ(0, 0.75, 0.75, -0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(2), 0.0, 0), 2e-3);
	EXPECT_NEAR(hopfion.getHX(0, 0.75, 0.75, -0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(3), 0.0, 0), 2e-3);
	EXPECT_NEAR(hopfion.getHY(0, 0.75, 0.75, -0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(4), 0.0, 0), 2e-3);
	EXPECT_NEAR(hopfion.getHZ(0, 0.75, 0.75, -0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(5), 0.0, 0), 2e-3);

	EXPECT_NEAR(hopfion.getEX(1.5, 0.75, 0.75, -0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(0), 1.5, 0), 2e-3);
	EXPECT_NEAR(hopfion.getEY(1.5, 0.75, 0.75, -0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(1), 1.5, 0), 2e-3);
	EXPECT_NEAR(hopfion.getEZ(1.5, 0.75, 0.75, -0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(2), 1.5, 0), 2e-3);
	EXPECT_NEAR(hopfion.getHX(1.5, 0.75, 0.75, -0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(3), 1.5, 0), 2e-3);
	EXPECT_NEAR(hopfion.getHY(1.5, 0.75, 0.75, -0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(4), 1.5, 0), 2e-3);
	EXPECT_NEAR(hopfion.getHZ(1.5, 0.75, 0.75, -0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(5), 1.5, 0), 2e-3);


	// Punto 3: { 0.00, 0.00, 0.00 }= center
	EXPECT_NEAR(hopfion.getEX(0, 0.00, 0.00, 0.00), getBoundaryFieldValueAtTime(solver.getPointsProbe(0), 0.0, 0), 2e-3);
	EXPECT_NEAR(hopfion.getEY(0, 0.00, 0.00, 0.00), getBoundaryFieldValueAtTime(solver.getPointsProbe(1), 0.0, 0), 2e-3);
	EXPECT_NEAR(hopfion.getEZ(0, 0.00, 0.00, 0.00), getBoundaryFieldValueAtTime(solver.getPointsProbe(2), 0.0, 0), 2e-3);
	EXPECT_NEAR(hopfion.getHX(0, 0.00, 0.00, 0.00), getBoundaryFieldValueAtTime(solver.getPointsProbe(3), 0.0, 0), 2e-3);
	EXPECT_NEAR(hopfion.getHY(0, 0.00, 0.00, 0.00), getBoundaryFieldValueAtTime(solver.getPointsProbe(4), 0.0, 0), 2e-3);
	EXPECT_NEAR(hopfion.getHZ(0, 0.00, 0.00, 0.00), getBoundaryFieldValueAtTime(solver.getPointsProbe(5), 0.0, 0), 2e-3);

	EXPECT_NEAR(hopfion.getEX(1.5, 0.00, 0.00, 0.00), getBoundaryFieldValueAtTime(solver.getPointsProbe(0), 1.5, 0), 2e-3);
	EXPECT_NEAR(hopfion.getEY(1.5, 0.00, 0.00, 0.00), getBoundaryFieldValueAtTime(solver.getPointsProbe(1), 1.5, 0), 2e-3);
	EXPECT_NEAR(hopfion.getEZ(1.5, 0.00, 0.00, 0.00), getBoundaryFieldValueAtTime(solver.getPointsProbe(2), 1.5, 0), 2e-3);
	EXPECT_NEAR(hopfion.getHX(1.5, 0.00, 0.00, 0.00), getBoundaryFieldValueAtTime(solver.getPointsProbe(3), 1.5, 0), 2e-3);
	EXPECT_NEAR(hopfion.getHY(1.5, 0.00, 0.00, 0.00), getBoundaryFieldValueAtTime(solver.getPointsProbe(4), 1.5, 0), 2e-3);
	EXPECT_NEAR(hopfion.getHZ(1.5, 0.00, 0.00, 0.00), getBoundaryFieldValueAtTime(solver.getPointsProbe(5), 1.5, 0), 2e-3);



	// Punto 4:  { 0.75, -0.75, 0.75 } 
	EXPECT_NEAR(hopfion.getEX(0, 0.75, -0.75, 0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(0), 0.0, 0), 2e-3);
	EXPECT_NEAR(hopfion.getEY(0, 0.75, -0.75, 0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(1), 0.0, 0), 2e-3);
	EXPECT_NEAR(hopfion.getEZ(0, 0.75, -0.75, 0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(2), 0.0, 0), 2e-3);
	EXPECT_NEAR(hopfion.getHX(0, 0.75, -0.75, 0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(3), 0.0, 0), 2e-3);
	EXPECT_NEAR(hopfion.getHY(0, 0.75, -0.75, 0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(4), 0.0, 0), 2e-3);
	EXPECT_NEAR(hopfion.getHZ(0, 0.75, -0.75, 0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(5), 0.0, 0), 2e-3);

	EXPECT_NEAR(hopfion.getEX(1.5, 0.75, -0.75, 0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(0), 1.5, 0), 2e-3);
	EXPECT_NEAR(hopfion.getEY(1.5, 0.75, -0.75, 0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(1), 1.5, 0), 2e-3);
	EXPECT_NEAR(hopfion.getEZ(1.5, 0.75, -0.75, 0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(2), 1.5, 0), 2e-3);
	EXPECT_NEAR(hopfion.getHX(1.5, 0.75, -0.75, 0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(3), 1.5, 0), 2e-3);
	EXPECT_NEAR(hopfion.getHY(1.5, 0.75, -0.75, 0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(4), 1.5, 0), 2e-3);
	EXPECT_NEAR(hopfion.getHZ(1.5, 0.75, -0.75, 0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(5), 1.5, 0), 2e-3);



	// Punto 5: { -0.75, 0.75, -0.75 }
	EXPECT_NEAR(hopfion.getEX(0, -0.75, 0.75, -0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(0), 0.0, 0), 2e-3);
	EXPECT_NEAR(hopfion.getEY(0, -0.75, 0.75, -0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(1), 0.0, 0), 2e-3);
	EXPECT_NEAR(hopfion.getEZ(0, -0.75, 0.75, -0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(2), 0.0, 0), 2e-3);
	EXPECT_NEAR(hopfion.getHX(0, -0.75, 0.75, -0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(3), 0.0, 0), 2e-3);
	EXPECT_NEAR(hopfion.getHY(0, -0.75, 0.75, -0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(4), 0.0, 0), 2e-3);
	EXPECT_NEAR(hopfion.getHZ(0, -0.75, 0.75, -0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(5), 0.0, 0), 2e-3);

	EXPECT_NEAR(hopfion.getEX(1.5, -0.75, 0.75, -0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(0), 1.5, 0), 2e-3);
	EXPECT_NEAR(hopfion.getEY(1.5, -0.75, 0.75, -0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(1), 1.5, 0), 2e-3);
	EXPECT_NEAR(hopfion.getEZ(1.5, -0.75, 0.75, -0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(2), 1.5, 0), 2e-3);
	EXPECT_NEAR(hopfion.getHX(1.5, -0.75, 0.75, -0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(3), 1.5, 0), 2e-3);
	EXPECT_NEAR(hopfion.getHY(1.5, -0.75, 0.75, -0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(4), 1.5, 0), 2e-3);
	EXPECT_NEAR(hopfion.getHZ(1.5, -0.75, 0.75, -0.75), getBoundaryFieldValueAtTime(solver.getPointsProbe(5), 1.5, 0), 2e-3);


}

TEST_F(TestHopfion, normL2HopfionInicialGetRef)
{
	Hopfion hopfion(1, 1);

	double ngEx1 = 0.0;
	double ngEy1 = 0.0;
	double ngEz1 = 0.0;

	double ngHx1 = 0.0;
	double ngHy1 = 0.0;
	double ngHz1 = 0.0;


	for (double x1 = -4.0; x1 <= 6.0; x1 = x1 + 2)
	{
		for (double y1 = -4.0; y1 <= 6.0; y1 = y1 + 2)
		{
			for (double z1 = -4.0; z1 <= 6.0; z1 = z1 + 2)
			{
				ngEx1 += hopfion.getEX(0, x1, y1, z1) * hopfion.getEX(0, x1, y1, z1); 
				ngEy1 += hopfion.getEY(0, x1, y1, z1) * hopfion.getEY(0, x1, y1, z1); 
				ngEz1 += hopfion.getEZ(0, x1, y1, z1) * hopfion.getEZ(0, x1, y1, z1); 
										   								   			
				ngHx1 += hopfion.getHX(0, x1, y1, z1) * hopfion.getHX(0, x1, y1, z1); 
				ngHy1 += hopfion.getHY(0, x1, y1, z1) * hopfion.getHY(0, x1, y1, z1); 
				ngHz1 += hopfion.getHZ(0, x1, y1, z1) * hopfion.getHZ(0, x1, y1, z1); 

			}

		}
	}

	double nrEx = 0.0;
	double nrEy = 0.0;
	double nrEz = 0.0;
	double nrHx = 0.0;
	double nrHy = 0.0;
	double nrHz = 0.0;

	double ngEx2 = 0.0;
	double ngEy2 = 0.0;
	double ngEz2 = 0.0;
	double ngHx2 = 0.0;
	double ngHy2 = 0.0;
	double ngHz2 = 0.0;

	double x, y, z, rEx, rEy, rEz, rHx, rHy, rHz;
	Time t;

	std::string path = "testData/hopfion/"; // -4, +6
	std::string casename = "hopfion_p1_q1.txt";

	std::ifstream inputFile;
	std::string filename = path + casename;
	inputFile.open(filename);
	if (!inputFile.is_open()) {
		throw std::runtime_error("Could not open file: " + filename);
	}

	while (!inputFile.eof()) {

		inputFile >> t >> x >> y >> z >> rEx >> rEy >> rEz >> rHx >> rHy >> rHz;

		nrEx = nrEx + rEx * rEx;
		nrEy = nrEy + rEy * rEy;
		nrEz = nrEz + rEz * rEz;

		nrHx = nrHx + rHx * rHx;
		nrHy = nrHy + rHy * rHy;
		nrHz = nrHz + rHz * rHz;

		ngEx2 += hopfion.getEX(0, x, y, z) * hopfion.getEX(0, x, y, z);
		ngEy2 += hopfion.getEY(0, x, y, z) * hopfion.getEY(0, x, y, z);
		ngEz2 += hopfion.getEZ(0, x, y, z) * hopfion.getEZ(0, x, y, z);

		ngHx2 += hopfion.getHX(0, x, y, z) * hopfion.getHX(0, x, y, z);
		ngHy2 += hopfion.getHY(0, x, y, z) * hopfion.getHY(0, x, y, z);
		ngHz2 += hopfion.getHZ(0, x, y, z) * hopfion.getHZ(0, x, y, z);

	}

	EXPECT_NEAR(sqrt(nrEx), sqrt(ngEx1), 1e-3);
	EXPECT_NEAR(sqrt(nrEy), sqrt(ngEy1), 1e-3);
	EXPECT_NEAR(sqrt(nrEz), sqrt(ngEz1), 1e-3);
	EXPECT_NEAR(sqrt(nrHx), sqrt(ngHx1), 1e-3);
	EXPECT_NEAR(sqrt(nrHy), sqrt(ngHy1), 1e-3);
	EXPECT_NEAR(sqrt(nrHz), sqrt(ngHz1), 1e-3);

	EXPECT_NEAR(sqrt(nrEx), sqrt(ngEx2), 1e-3);
	EXPECT_NEAR(sqrt(nrEy), sqrt(ngEy2), 1e-3);
	EXPECT_NEAR(sqrt(nrEz), sqrt(ngEz2), 1e-3);
	EXPECT_NEAR(sqrt(nrHx), sqrt(ngHx2), 1e-3);
	EXPECT_NEAR(sqrt(nrHy), sqrt(ngHy2), 1e-3);
	EXPECT_NEAR(sqrt(nrHz), sqrt(ngHz2), 1e-3);

	EXPECT_NEAR(6.0, x, 1e-3);
	EXPECT_NEAR(6.0, y, 1e-3);
	EXPECT_NEAR(6.0, z, 1e-3);
}

TEST_F(TestHopfion, DISABLED_normL2HopfionInicialRunRef)
{
	Mesh mesh = Mesh::MakeCartesian3D(4, 4, 4, Element::Type::HEXAHEDRON, 4, 4, 4);

	Model model = Model(mesh, AttributeToMaterial(), AttributeToBoundary());
	
	Probes probes;
	probes.addExporterProbeToCollection(ExporterProbe());
	probes.vis_steps = 20;

	Sources sources;
	sources.addSourceToVector(Source(model, E, Y, 2.0, 9.6, Vector({ 1.0, 1.0, 1.0 }), SourceType::Hopfion));

	maxwell::Solver::Options solverOpts = buildDefaultSolverOpts(1.5);
	//solverOpts.order = 4;

	maxwell::Solver solver(model, probes, sources, solverOpts);

	GridFunction eOldX = solver.getFieldInDirection(E, X);
	GridFunction eOldY = solver.getFieldInDirection(E, Y);
	GridFunction eOldZ = solver.getFieldInDirection(E, Z);
	GridFunction hOldX = solver.getFieldInDirection(H, X);
	GridFunction hOldY = solver.getFieldInDirection(H, Y);
	GridFunction hOldZ = solver.getFieldInDirection(H, Z);

	double x, y, z, rEx, rEy, rEz, rHx, rHy, rHz;

	DG_FECollection fec(solverOpts.order, mesh.Dimension(), BasisType::GaussLobatto);
	FiniteElementSpace fes(&mesh, &fec);
	mfem::FunctionCoefficient u0(hopfionLineEx);
	GridFunction u(&fes);
	u.ProjectCoefficient(u0);

	EXPECT_NEAR(u.Norml2(), eOldX.Norml2(), 1e-3);
	EXPECT_NEAR(u.Norml2(), eOldY.Norml2(), 1e-3);
	EXPECT_NEAR(u.Norml2(), eOldZ.Norml2(), 1e-3);
	EXPECT_NEAR(u.Norml2(), hOldX.Norml2(), 1e-3);
	EXPECT_NEAR(u.Norml2(), hOldY.Norml2(), 1e-3);
	EXPECT_NEAR(u.Norml2(), hOldZ.Norml2(), 1e-3);


	double errorEX = u.Norml2() - eOldX.Norml2();
	EXPECT_NEAR(0.0, errorEX, 2e-3);

	double errorEY = u.Norml2() - eOldY.Norml2();
	EXPECT_NEAR(0.0, errorEY, 2e-3);

	double errorEZ = u.Norml2() - eOldZ.Norml2();
	EXPECT_NEAR(0.0, errorEZ, 2e-3);


	double errorHX = u.Norml2() - hOldX.Norml2();
	EXPECT_NEAR(0.0, errorHX, 2e-3);

	double errorHY = u.Norml2() - hOldY.Norml2();
	EXPECT_NEAR(0.0, errorHY, 2e-3);

	double errorHZ = u.Norml2() - hOldZ.Norml2();
	EXPECT_NEAR(0.0, errorHZ, 2e-3);


	/*double errorEX = eOldX.DistanceTo(grEx);
	EXPECT_NEAR(0.0, errorEX, 2e-3);

	double errorEY = eOldX.DistanceTo(grEy);
	EXPECT_NEAR(0.0, errorEY, 2e-3);

	double errorEZ = eOldX.DistanceTo(grEz);
	EXPECT_NEAR(0.0, errorEZ, 2e-3);


	double errorHX = eOldX.DistanceTo(grHx);
	EXPECT_NEAR(0.0, errorHX, 2e-3);

	double errorHY = eOldX.DistanceTo(grHy);
	EXPECT_NEAR(0.0, errorHY, 2e-3);

	double errorHZ = eOldX.DistanceTo(grHz);
	EXPECT_NEAR(0.0, errorHZ, 2e-3);*/
}
TEST_F(TestHopfion, checkMeshForRefHopfion)
{
	Mesh mesh = Mesh::MakeCartesian3D(6, 6, 6, Element::Type::HEXAHEDRON);

	Model model = Model(mesh, AttributeToMaterial(), AttributeToBoundary());

	Sources sources;
	sources.addSourceToVector(Source(model, E, Y, 2.0, 9.6, Vector({ 1.0, 1.0, 1.0 }), SourceType::Hopfion));

	Vector posMax = sources.getMaxBBi();
	Vector posMin = sources.getMinBBi();

	Vector center = posMax;
	center.Add(1.0, posMin);
	center /= 2.0;

	EXPECT_EQ(posMax[X], 1.0);
	EXPECT_EQ(posMin[X], 0.0);
	EXPECT_EQ(center[X], 0.5);

	EXPECT_EQ(posMax[Y], 1.0);
	EXPECT_EQ(posMin[Y], 0.0);
	EXPECT_EQ(center[Y], 0.5);

	EXPECT_EQ(posMax[Z], 1.0);
	EXPECT_EQ(posMin[Z], 0.0);
	EXPECT_EQ(center[Z], 0.5);

	Vector normalizedCenter(3);
	Vector normalizedMax(3);
	Vector normalizedMin(3);

	Vector hopCenter(3);
	Vector hopMax(3);
	Vector hopMin(3);

	for (int i = 0; i < 3; i++) {
		normalizedCenter[i] = (0.5 - center[i])/(posMax[i]-posMin[i]);
		normalizedMax[i] = (posMax[i] - center[i]) / (posMax[i] - posMin[i]);
		normalizedMin[i] = (posMin[i] - center[i])/ (posMax[i] - posMin[i]);
		hopCenter[i] = (10 * (normalizedCenter[i])) + 1.0;
		hopMax[i] = (10 * (normalizedMax[i])) + 1.0 ;
		hopMin[i] = (10 * (normalizedMin[i])) + 1.0;

	}

	EXPECT_EQ(normalizedMax[X], 0.5);
	EXPECT_EQ(normalizedMin[X], -0.5);
	EXPECT_EQ(normalizedCenter[X], 0.0);
	EXPECT_EQ(hopCenter[X], 1.0);
	EXPECT_EQ(hopMax[X], 6.0);
	EXPECT_EQ(hopMin[X], -4.0);
			  
	EXPECT_EQ(normalizedMax[Y], 0.5);
	EXPECT_EQ(normalizedMin[Y],- 0.5);
	EXPECT_EQ(normalizedCenter[Y], 0.0);
	EXPECT_EQ(hopCenter[Y], 1.0);
	EXPECT_EQ(hopMax[Y], 6.0);
	EXPECT_EQ(hopMin[Y], -4.0);
			  
	EXPECT_EQ(normalizedMax[Z], 0.5);
	EXPECT_EQ(normalizedMin[Z], -0.5);
	EXPECT_EQ(normalizedCenter[Z], 0.0);
	EXPECT_EQ(hopCenter[Z], 1.0);
	EXPECT_EQ(hopMax[Z], 6.0);
	EXPECT_EQ(hopMin[Z], -4.0);

}

TEST_F(TestHopfion, hopfionFinal)
{
	Mesh mesh = Mesh::MakeCartesian3D(6, 6, 6, Element::Type::HEXAHEDRON);
	Model model = Model(mesh, AttributeToMaterial(), AttributeToBoundary());

	Probes probes;
	probes.vis_steps = 20;
	probes.addPointsProbeToCollection(PointsProbe(E, X, std::vector<std::vector<double>>{ { 0.5, 0.5, 0.5 } }));
	probes.addPointsProbeToCollection(PointsProbe(E, Y, std::vector<std::vector<double>>{ { 0.5, 0.5, 0.5 } }));
	probes.addPointsProbeToCollection(PointsProbe(E, Z, std::vector<std::vector<double>>{ { 0.5, 0.5, 0.5 } }));
	probes.addPointsProbeToCollection(PointsProbe(H, X, std::vector<std::vector<double>>{ { 0.5, 0.5, 0.5 } }));
	probes.addPointsProbeToCollection(PointsProbe(H, Y, std::vector<std::vector<double>>{ { 0.5, 0.5, 0.5 } }));
	probes.addPointsProbeToCollection(PointsProbe(H, Z, std::vector<std::vector<double>>{ { 0.5, 0.5, 0.5 } }));

	Sources sources;
	sources.addSourceToVector(Source(model, E, Y, 1.0, 1.0, Vector({ 1.0, 1.0, 1.0 }), SourceType::Hopfion));

	maxwell::Solver::Options solverOpts = buildDefaultSolverOpts();
	solverOpts.order = 3;

	maxwell::Solver solver(model, probes, sources, solverOpts);

	GridFunction eOldX = solver.getFieldInDirection(E, X);
	GridFunction eOldY = solver.getFieldInDirection(E, Y);
	GridFunction eOldZ = solver.getFieldInDirection(E, Z);
	GridFunction hOldX = solver.getFieldInDirection(H, X);
	GridFunction hOldY = solver.getFieldInDirection(H, Y);
	GridFunction hOldZ = solver.getFieldInDirection(H, Z);
	solver.run();
	GridFunction eNewX = solver.getFieldInDirection(E, X);
	GridFunction eNewY = solver.getFieldInDirection(E, Y);
	GridFunction eNewZ = solver.getFieldInDirection(E, Z);
	GridFunction hNewX = solver.getFieldInDirection(H, X);
	GridFunction hNewY = solver.getFieldInDirection(H, Y);
	GridFunction hNewZ = solver.getFieldInDirection(H, Z);


	double Eie = pow(eOldX.Norml2(), 2.0) + pow(eOldY.Norml2(), 2.0) + pow(eOldZ.Norml2(), 2.0);
	double Eih = pow(hOldX.Norml2(), 2.0) + pow(hOldY.Norml2(), 2.0) + pow(hOldZ.Norml2(), 2.0);

	double Efe = pow(eNewX.Norml2(), 2.0) + pow(eNewY.Norml2(), 2.0) + pow(eNewZ.Norml2(), 2.0);
	double Efh = pow(hNewX.Norml2(), 2.0) + pow(hNewY.Norml2(), 2.0) + pow(hNewZ.Norml2(), 2.0);

	EXPECT_GE(Eie + Eih, Efe + Efh);

	Hopfion hopfion(1, 1);

	double ExfT = hopfion.getEX(0.5, 0.75, 0.75, 0.75);
	double EyfT = hopfion.getEY(0.5, 0.75, 0.75, 0.75);
	double EzfT = hopfion.getEZ(0.5, 0.75, 0.75, 0.75);
	double HxfT = hopfion.getHX(0.5, 0.75, 0.75, 0.75);
	double HyfT = hopfion.getHY(0.5, 0.75, 0.75, 0.75);
	double HzfT = hopfion.getHZ(0.5, 0.75, 0.75, 0.75);

	EXPECT_NEAR(ExfT, getBoundaryFieldValueAtTime(solver.getPointsProbe(0), 0.5, 0), 2e-3);
	EXPECT_NEAR(EyfT, getBoundaryFieldValueAtTime(solver.getPointsProbe(1), 0.5, 0), 2e-3);
	EXPECT_NEAR(EzfT, getBoundaryFieldValueAtTime(solver.getPointsProbe(2), 0.5, 0), 2e-3);
	EXPECT_NEAR(HxfT, getBoundaryFieldValueAtTime(solver.getPointsProbe(3), 0.5, 0), 2e-3);
	EXPECT_NEAR(HyfT, getBoundaryFieldValueAtTime(solver.getPointsProbe(4), 0.5, 0), 2e-3);
	EXPECT_NEAR(HzfT, getBoundaryFieldValueAtTime(solver.getPointsProbe(5), 0.5, 0), 2e-3);
}

TEST_F(TestHopfion, hopfionPlot)
{
	Mesh mesh = Mesh::MakeCartesian3D(3, 3, 3, Element::Type::TETRAHEDRON); //, 2, 2, 2
	Model model = Model(mesh, AttributeToMaterial(), AttributeToBoundary());

	Probes probes;
	probes.vis_steps = 20;
	probes.addPointsProbeToCollection(PointsProbe(E, X, std::vector<std::vector<double>>{ { 0.8, 0.0, 0.0 } }));
	/*probes.addPointsProbeToCollection(PointsProbe(E, Y, std::vector<std::vector<double>>{ { 0.75, 0.75, 0.75 } }));
	probes.addPointsProbeToCollection(PointsProbe(E, Z, std::vector<std::vector<double>>{ { 0.75, 0.75, 0.75 } }));
	probes.addPointsProbeToCollection(PointsProbe(H, X, std::vector<std::vector<double>>{ { 0.75, 0.75, 0.75 } }));
	probes.addPointsProbeToCollection(PointsProbe(H, Y, std::vector<std::vector<double>>{ { 0.75, 0.75, 0.75 } }));
	probes.addPointsProbeToCollection(PointsProbe(H, Z, std::vector<std::vector<double>>{ { 0.75, 0.75, 0.75 } }));*/

	Sources sources;
	sources.addSourceToVector(Source(model, E, Y, 1.0, 1.0, Vector({ 1.0, 1.0, 1.0 }), SourceType::Hopfion));

	maxwell::Solver::Options solverOpts = buildDefaultSolverOpts();
	//solverOpts.order = 3;

	maxwell::Solver solver(model, probes, sources, solverOpts);

	solver.run();

	std::vector<double> ExrT;
	/*std::vector<double> EyrT;
	std::vector<double> EzrT;
						  
	std::vector<double> HxrT;
	std::vector<double> HyrT;
	std::vector<double> HzrT;*/

	std::vector<double> ExsT;
	/*std::vector<double> EysT;
	std::vector<double> EzsT;
						  
	std::vector<double> HxsT;
	std::vector<double> HysT;
	std::vector<double> HzsT;*/

	std::vector<double> TimeErr;

	std::vector<double> errEx;
	/*std::vector<double> errEy;
	std::vector<double> errEz;
	std::vector<double> errHx;
	std::vector<double> errHy;
	std::vector<double> errHz;*/

	Hopfion hopfion(1, 1);
	int N = 100;
	double t;


	std::string path = "testData/hopfion/";
	std::string casename = "hopfionErrEx121200.txt";
	std::ofstream  inputFile;
	std::string filename = path + casename;
	inputFile.open(filename);
	if (!inputFile.is_open()) {
		throw std::runtime_error("Could not open file: " + filename);
	}

	for (size_t i = 0; i <= N; i++)
	{
		t = (2.0*i) / (N*1.0);
		ExrT.push_back(hopfion.getEX(t, 1.2, 1.2, 0.0));
		/*EyrT.push_back(hopfion.getEY(2, 0.75, 0.75, 0.75));
		EzrT.push_back(hopfion.getEZ(2, 0.75, 0.75, 0.75));
		HxrT.push_back(hopfion.getHX(2, 0.75, 0.75, 0.75));
		HyrT.push_back(hopfion.getHY(2, 0.75, 0.75, 0.75));
		HzrT.push_back(hopfion.getHZ(2, 0.75, 0.75, 0.75));*/

		ExsT.push_back(getBoundaryFieldValueAtTime(solver.getPointsProbe(0), t, 0));
	/*	EysT.push_back(getBoundaryFieldValueAtTime(solver.getPointsProbe(1), t, 0));
		EzsT.push_back(getBoundaryFieldValueAtTime(solver.getPointsProbe(2), t, 0));
		HxsT.push_back(getBoundaryFieldValueAtTime(solver.getPointsProbe(3), t, 0));
		HysT.push_back(getBoundaryFieldValueAtTime(solver.getPointsProbe(4), t, 0));
		HzsT.push_back(getBoundaryFieldValueAtTime(solver.getPointsProbe(5), t, 0));*/

		TimeErr.push_back(t);
		errEx.push_back(abs(ExrT[i] - ExsT[i]) );
		/*errEx.push_back(abs(ExrT.at(i) - ExsT.at(i)));
		errEy.push_back(abs(EyrT.at(i) - EysT.at(i)));
		errEz.push_back(abs(EzrT.at(i) - EzsT.at(i)));
		errHx.push_back(abs(HxrT.at(i) - HxsT.at(i)));
		errHy.push_back(abs(HyrT.at(i) - HysT.at(i)));
		errHz.push_back(abs(HzrT.at(i) - HzsT.at(i)));*/

		inputFile << TimeErr[i] << " , " << errEx[i] << std::endl;

	}

	EXPECT_NEAR(ExrT.at(0), ExsT.at(0), 2e-3);
	EXPECT_NEAR(ExrT.at(1), ExsT.at(1), 2e-3);
	EXPECT_NEAR(ExrT.at(2), ExsT.at(2), 2e-3);
	EXPECT_NEAR(ExrT.at(3), ExsT.at(3), 2e-3);
	EXPECT_NEAR(ExrT.at(4), ExsT.at(4), 2e-3);
	EXPECT_NEAR(ExrT.at(5), ExsT.at(5), 2e-3);
	/*EXPECT_NEAR(EzrT.at(50), EzsT.at(50), 2e-3);
	EXPECT_NEAR(HxrT.at(50), HxsT.at(50), 2e-3);
	EXPECT_NEAR(HyrT.at(50), HysT.at(50), 2e-3);
	EXPECT_NEAR(HzrT.at(50), HzsT.at(50), 2e-3);
	EXPECT_NEAR(ExrT.at(50), ExsT.at(50), 2e-3);*/

	inputFile.close();

}

TEST_F(TestHopfion, hopfionLine)
{
	Mesh mesh = Mesh::MakeCartesian3D(6, 6, 6, Element::Type::TETRAHEDRON, 6, 6, 6);
	Model model = Model(mesh, AttributeToMaterial(), AttributeToBoundary());

	Probes probes;
	probes.addPointsProbeToCollection(PointsProbe(E, X, std::vector<std::vector<double>>{ {  3.5, 3.0, 3.0 } }));
	probes.addExporterProbeToCollection(ExporterProbe());
	probes.vis_steps = 20;

	Sources sources;
	sources.addSourceToVector(Source(model, E, Y, 2.0, 9.6, Vector({ 1.0, 1.0, 1.0 }), SourceType::Hopfion));

	maxwell::Solver::Options solverOpts = buildDefaultSolverOpts();
	solverOpts.evolutionOperatorOptions.fluxType = FluxType::Centered;
	//solverOpts.order = 3;


	maxwell::Solver solver(
		model,
		probes,
		sources,
		solverOpts
	);

	solver.run();
	Hopfion hopfion(1, 1);
	EXPECT_NEAR(hopfion.getEX(0.0, 3.5, 3.0, 3.0), getBoundaryFieldValueAtTime(solver.getPointsProbe(0), 0.0, 0), 2e-3);

	DG_FECollection fec(solverOpts.order, mesh.Dimension(), BasisType::GaussLobatto);
	FiniteElementSpace fes(&mesh, &fec);
	mfem::FunctionCoefficient u0(hopfionLineEx);
	GridFunction u(&fes);
	u.ProjectCoefficient(u0);

	std::unique_ptr<mfem::ParaViewDataCollection> pd = std::make_unique<ParaViewDataCollection>("Maxwell", &mesh);
	pd->SetPrefixPath("ParaView");
	pd->RegisterField("Extheo", &u);
	pd->SetLevelsOfDetail(solverOpts.order);
	pd->SetDataFormat(VTKFormat::BINARY);
	solverOpts.order > 0 ? pd->SetHighOrderOutput(true) : pd->SetHighOrderOutput(false);
	pd->SetCycle(0);
	pd->SetTime(0.0);
	pd->Save();


}